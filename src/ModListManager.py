#!/usr/bin/env python

from Engine import NexusApi, InputManager

import time
from datetime import datetime, timezone
import json
from pathlib import Path
import webbrowser

# The function to be executed at runtime
def main():
    
    # PREP-WORK: DO NOT SKIP THIS!
    #
    # Step 1: Install Python and its required libraries.
    # You can get python for your OS here: https://www.python.org/downloads/
    #
    # Step 2: Separately, you must install the requests library. This is used to access the API.
    # Type the following into a terminal/command prompt: "python -m pip install requests"
    #
    # Step 3: An API Token MUST be generated by logging into NexusMods and navigating to the following link: https://www.nexusmods.com/users/myaccount?tab=api%20access. 
    # DO NOT SHARE THIS TOKEN WITH ANYONE. This script also does not save the token anywhere, you must enter it again each time you run the script.
    #
    # Step 4: If you are running the script to update an existing list, be sure to move the JSON file for your mod list from "Results" to "ModLists" folder first.
    
    # CONFIG: Change the following to alter the execution of the script.
    
    # New mods. Add ID of each new mod(s) here and they will be added to the list of mods to grab (if they aren't there already)
    addModIdList = [754,2370,6282,6960,2404,1746,2967]
    
    # The game to search for mod.
    # This is the name that is used in the URL when viewing mods in your browser, e.g. https://www.nexusmods.com/baldursgate3/mods/####
    gameDomain = "baldursgate3"
    
    # Pause/sleep constant. Change this if you want to have shorter pauses after each prompt. Recommended to keep at >=0.1
    pauseTime = 0.1
    
    # Default mod file name. If none is provided during the script, this is the name that gets used.
    defaultFileName = "data"

    # END OF CONFIG
    
    ############################################
    
    # REST OF THE FRACKING SCRIPT. DO NOT TOUCH!
    
    # Initialize API interface
    # Request API Key from user
    apiKey = input("Enter API Access Key: ")
    time.sleep(pauseTime)
    nexusMods = NexusApi(apiKey)
    
    # Test if file exists
    fileName = input("Enter mod list json file name: ")
    time.sleep(pauseTime)
    
    # Check if file name is provided, if none is provided it will switch to the default
    if (not fileName):
        print("Blank file name provided! Using default name '"+ defaultFileName + "'")
        fileName = defaultFileName
    
    fileDirectory = "ModLists/"
    fileExtension = ".json"
    filePath = Path(fileDirectory + fileName)
    if (fileName[-len(fileExtension):] != fileExtension):
        print("File name "+ fileName + " missing extension. Appending '.json' to end.")
        filePath = Path(fileDirectory + fileName + fileExtension)
    
    
    
    inputModList = None
    modIdList = []
    
    
    if Path.exists(filePath):
        f = open(filePath)
        inputModList = json.load(f)
        print("Loaded File '" + fileName + "' successfully!")
        print("File Contents: " + json.dumps(inputModList))
        f.close()
        for mod in inputModList:
            modIdList.append(mod["id"])
    else:
        print("Filename '" + fileName + "' not found!")
        # If original mod list cannot be found, prompt user for input
        continueOnFileNotFound = InputManager.falsyBooleanInput("Continue script (y/*)? ", "y")
        time.sleep(pauseTime)
        # If the user wants to continue
        if (continueOnFileNotFound):
            print("Continuing script!")
        else:
            print("Stopping script!")
            return
    
    # Get count of original mods
    inputCount = len(modIdList)
    
    # check additional mod IDs and add if missing
    for modId in addModIdList:
        if not modId in modIdList:
            modIdList.append(modId)
            print("Added modId " + str(modId) + " to list.")
        else:
            print("ModId " + str(modId) + " already in loaded file, ignoring!")
    
    print("List of modIds to check: " + str(modIdList))
    
    outputModList = []
    updatesRequired = []
    
    totalMods = len(modIdList)
    
    
    # Mod Info format
    # mod = {"name": "ABC123","id": 123,"updatedTime": "YYYY-MM-DDTHH:MM:SS.SSS+TZ","lastDownloaded":"YYYY-MM-DDTHH:MM:SS.SSS+TZ","url":"https://www.nexusmods.com/gameDomain/mods/modId"}
    
    
    # Check all modIds on NexusMods while tracking index
    for index,modId in enumerate(modIdList):
        print("Checking modId="+str(modId) + " (mod #" + str(index+1) + "/" + str(totalMods) + ")")
        outputMod = {"name": None,"id": None,"updatedTime":None,"lastDownloaded":None,"url":None}
        getMod = nexusMods.getMod(game=gameDomain,id=modId)
        getModJson = getMod.json()
        
        # Assemble Mod Info
        outputMod["name"] = getModJson["name"]
        outputMod["id"] = modId
        outputMod["updatedTime"] = getModJson["updated_time"]
        outputMod["url"] = "https://www.nexusmods.com/"+gameDomain+"/mods/"+str(modId)
        
        
        # Compare updatedTimestamp and lastUpdated timestamps
        
        # If it is before the end of the original list, run standard check. Else, automatically add to flagged update list
        if (index < inputCount):
            # If it doesn't have a timestamp, default to adding it to the list
            if (not inputModList[index]["lastDownloaded"]):
                print("modId="+ str(modId) +" doesn't have lastDownloaded, flagging for update!")
                updatesRequired.append(index)
            else:
                # Copy old download timestamp
                outputMod["lastDownloaded"] = inputModList[index]["lastDownloaded"]
                
                # Process timestamps
                lastDownloadedTime = datetime.fromisoformat(outputMod["lastDownloaded"])
                lastUpdatedTime = datetime.fromisoformat(outputMod["updatedTime"])
                
                # Change lastUpdatedTime to match lastDownloaded timezone
                lastDownloadedTimezone = lastDownloadedTime.tzinfo
                lastUpdatedTime = lastUpdatedTime.astimezone(lastDownloadedTimezone)
                
                # Compare the times to determine if an update occured since lastDownloaded
                if (lastDownloadedTime < lastUpdatedTime):
                    print("modId="+ str(modId) +" hasn't updated since lastDownloaded, but the mod page has been. Flagging for update!")
                    updatesRequired.append(index)
        else:
            # Mod is new, needs to initialize update
            print("modId="+ str(modId) +" is new mod, flagging for update!")
            updatesRequired.append(index)
        
        outputModList.append(outputMod)
        time.sleep(0.1)
    
    
    if (len(updatesRequired) > 0):
        print(str(len(updatesRequired)) + " mod(s) flagged for updates!")
        # If the mods should be checked for updates. 
        # Boolean. Will default to "False" on invalid input
        addressUpdates = InputManager.falsyBooleanInput("Address updates (y/*)? ", "y")
        time.sleep(pauseTime)
        
        # If positive input received
        if (addressUpdates):
            
            batchUpdate = InputManager.falsyBooleanInput("Open links en masse (y/*, will open all at once)? ", "y")
            time.sleep(pauseTime)
            batchLinks = []
            
            timeNow = datetime.now().astimezone(timezone.utc).isoformat(timespec='microseconds')
            # For each index flagged, address updates individually
            for index in updatesRequired:
                # Assemble mod info for use
                modName = outputModList[index]["name"]
                modId = outputModList[index]["id"]
                modUrl = outputModList[index]["url"]
                modUpdatedTime = outputModList[index]["updatedTime"]
                modLastDownloaded = outputModList[index]["lastDownloaded"]
                modIsNew = (not (index < inputCount))
                
                # Print mod info
                print("\nMod Name: " + str(modName))
                print("Mod ID: " + str(modId))
                print("URL: " + str(modUrl))
                print("Mod is new: " + str(modIsNew))
                print("Repo Updated: " + str(modUpdatedTime))
                print("Last Downloaded: " + str(modLastDownloaded))
                
                # Ask if you want to address this specific update
                addressModUpdate = InputManager.falsyBooleanInput("Open modpage (y/*)? ", "y")
                time.sleep(pauseTime)
                if (addressModUpdate):
                    # If batch links are enabled, add to list of links to open
                    if (batchUpdate):
                        batchLinks.append(modUrl)
                    else:
                        # Open the mod individually and prompt for input when done
                        webbrowser.open(modUrl)
                        # Wait for user input before proceeding
                        input("Press enter/return when ready to continue...")
                        time.sleep(pauseTime)
                
                # Ask if you want to update lastDownloaded to current time
                addLastDownloaded = InputManager.falsyBooleanInput("Add current time as lastDownloaded (y/*)? ", "y")
                time.sleep(pauseTime)
                if (addLastDownloaded):
                    outputModList[index]["lastDownloaded"] = timeNow
                    
                
            if (batchUpdate and (len(batchLinks) > 0) ):
                print("Opening " + str(len(batchLinks)) + " mod page(s)! This may take a minute...")
                for link in batchLinks:
                    webbrowser.open(link)
                    time.sleep(0.5)
                
                print("Finished opening " + str(len(batchLinks)) + " mod pages!")
            
            
            print("Finished addressing updates!")
        else:
            # Negative input was received
            print("Ignoring updates!")
    
    
    
    
    
    
    # Print final outputModList result
    print(outputModList)
    
    # Save to file
    
    # Generate new file name
    outputFileName = fileName
    
    newFileName = InputManager.falsyBooleanInput("New file name (y/*)? ", "y")
    time.sleep(pauseTime)
    
    if (newFileName):
        outputFileName = input("Enter new file name: ")
        time.sleep(pauseTime)
    
    
    # Remove file extension if it exists
    if (outputFileName[-len(fileExtension):] == fileExtension):
        outputFileName = outputFileName[:-len(fileExtension)]
        
    # Generate default output file path
    outputFileDirectory = fileDirectory + "Results/"
    outputFilePath = Path(outputFileDirectory + outputFileName + fileExtension)
    
    
    # If the output file name already exists, increase increment until new file name is reached
    if Path.exists(outputFilePath):
        print(outputFileName + fileExtension + " already exists!")
        index = 0
        while Path.exists(outputFilePath):
            index += 1
            outputFilePath = Path(outputFileDirectory + outputFileName + " (" + str(index) + ")" + fileExtension)
    
    
    print("Saving data as '"+ str(outputFilePath) +"'")
    
    # Save output contents
    with open(outputFilePath, 'w', encoding='utf-8') as f:
        json.dump(outputModList, f, ensure_ascii=False, indent=4)
    
if __name__ == '__main__':
    main()