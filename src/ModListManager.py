#!/usr/bin/env python

from Engine import NexusApi, InputManager

import time
from datetime import datetime, timezone
import json
from pathlib import Path
import webbrowser


# Initialize logger
import logging
dateFormat = '%Y-%m-%d %H:%M:%S'
logFormat = '[%(asctime)s.%(msecs)03d] %(name)s (%(levelname)s): %(msg)s'
log = logging.getLogger("ModListManager")
logging.basicConfig(format=logFormat,datefmt=dateFormat)
# Log Level = INFO
log.setLevel(logging.INFO)

# The function to be executed at runtime
def main():
    
    # PREP-WORK: DO NOT SKIP THIS!
    #
    # Step 1: Install Python and its required libraries.
    # You can get python for your OS here: https://www.python.org/downloads/
    #
    # Step 2: Separately, you must install the requests library. This is used to access the API.
    # Type the following into a terminal/command prompt: "python -m pip install requests"
    #
    # Step 3: An API Token MUST be generated by logging into NexusMods and navigating to the following link: https://www.nexusmods.com/users/myaccount?tab=api%20access. 
    # DO NOT SHARE THIS TOKEN WITH ANYONE. This script also does not save the token anywhere, you must enter it again each time you run the script.
    #
    # Step 4: If you are running the script to update an existing list, be sure to move the JSON file for your mod list from "Results" to "ModLists" folder first.
    
    # CONFIG: Change the following to alter the execution of the script.
    
    # New mods. Add ID of each new mod(s) here and they will be added to the list of mods to grab (if they aren't there already)
    addModIdList = [2700,858,3940]
    
    # The game to search for mod.
    # This is the name that is used in the URL when viewing mods in your browser, e.g. https://www.nexusmods.com/baldursgate3/mods/####
    gameDomain = "baldursgate3"
    
    # Pause/sleep constant. Change this if you want to have shorter pauses after each prompt. Recommended to keep at >=0.1
    pauseTime = 0.1
    
    # Default mod file name. If none is provided during the script, this is the name that gets used.
    defaultFileName = "data.json"

    # END OF CONFIG
    
    ############################################
    
    # REST OF THE FRACKING SCRIPT. DO NOT TOUCH!
    
    log.info("Beggining ModListManager.py script")
    
    log.info("Initializing \".\\ModLists\\\" and \".\\ModLists\\Results\\\" directories.")
    # Initialize directories
    fileDirectory = "ModLists/"
    outputFileDirectory = fileDirectory + "Results/"
    outputDirectoryPath = Path(outputFileDirectory)
    # If the required directories don't exist, make them
    outputDirectoryPath.mkdir(parents=True, exist_ok=True)
    
    # Initialize API interface
    # Request API Key from user
    log.info("Requesting Nexus Mods API access key.")
    apiKey = InputManager.basicInput("Enter API Access Key: ")
    time.sleep(pauseTime)
    
    log.info("Initializing NexusApi interface.")
    nexusMods = NexusApi(apiKey)
    
    # Test if file exists
    fileName = InputManager.basicInput("Enter mod list json file name: ")
    time.sleep(pauseTime)
    
    # Check if file name is provided, if none is provided it will switch to the default
    if (not fileName):
        log.info("Blank file name provided! Using default name \"{0}\"".format(defaultFileName))
        fileName = defaultFileName
    
    fileExtension = ".json"
    filePath = Path(fileDirectory + fileName)
    if (fileName[-len(fileExtension):] != fileExtension):
        log.info("File name \"{0}\" missing extension. Appending '.json' to end.".format(fileName))
        filePath = Path(fileDirectory + fileName + fileExtension)
    
    
    
    inputModList = None
    modIdList = []
    
    
    if Path.exists(filePath):
        f = open(filePath)
        inputModList = json.load(f)
        log.info("Loaded File \"{0}\" successfully!".format(fileName))
        log.info("{0}:\n{1}".format(fileName,json.dumps(inputModList)))
        f.close()
        for mod in inputModList:
            modIdList.append(mod["id"])
    else:
        log.warning("Filename \"{0}\" not found!".format(fileName))
        # If original mod list cannot be found, prompt user for input
        continueOnFileNotFound = InputManager.falsyBooleanInput("Continue script (y/*)? ", "y")
        time.sleep(pauseTime)
        # If the user wants to continue
        if (continueOnFileNotFound):
            log.info("Continuing script!")
        else:
            log.warning("Stopping script!")
            return
    
    # Get count of original mods
    inputCount = len(modIdList)
    
    
    # check additional mod IDs and add if missing
    for modId in addModIdList:
        if not modId in modIdList:
            modIdList.append(modId)
            log.info("Added modId {0} to list.".format(modId))
        else:
            log.warning("ModId {0} already in loaded file, ignoring!".format(modId))
    
    log.info("List of modId's to check: {0}".format(modIdList))
    
    outputModList = []
    updatesRequired = []
    
    totalMods = len(modIdList)
    newMods = totalMods-inputCount
    log.info("Mod counts:\n\tExisting Mods = {0},\n\tNew Mods = {1},\n\tTotal Mods = {2}".format(inputCount,newMods,totalMods))
    
    # Mod Info format
    # mod = {"name": "ABC123","id": 123,"updatedTime": "YYYY-MM-DDTHH:MM:SS.SSS+TZ","lastDownloaded":"YYYY-MM-DDTHH:MM:SS.SSS+TZ","url":"https://www.nexusmods.com/gameDomain/mods/modId"}
    
    
    # Check all modIds on NexusMods while tracking index
    for index,modId in enumerate(modIdList):
        log.info("Checking modId={0} (mod #{1}/{2})".format(modId,(index+1),totalMods))
        outputMod = {"name": None,"id": None,"updatedTime":None,"lastDownloaded":None,"url":None}
        getMod = nexusMods.getMod(game=gameDomain,id=modId)
        getModJson = getMod.json()
        
        # Assemble Mod Info
        outputMod["name"] = getModJson["name"]
        outputMod["id"] = modId
        outputMod["updatedTime"] = getModJson["updated_time"]
        outputMod["url"] = "https://www.nexusmods.com/"+gameDomain+"/mods/"+str(modId)
        
        
        # Compare updatedTimestamp and lastUpdated timestamps
        
        # If it is before the end of the original list, run standard check. Else, automatically add to flagged update list
        if (index < inputCount):
            # If it doesn't have a timestamp, default to adding it to the list
            if (not inputModList[index]["lastDownloaded"]):
                log.warning("modId={0} doesn't have lastDownloaded, flagging for update!".format(modId))
                updatesRequired.append(index)
            else:
                # Copy old download timestamp
                outputMod["lastDownloaded"] = inputModList[index]["lastDownloaded"]
                
                # Process timestamps
                lastDownloadedTime = datetime.fromisoformat(outputMod["lastDownloaded"])
                lastUpdatedTime = datetime.fromisoformat(outputMod["updatedTime"])
                
                # Change lastUpdatedTime to match lastDownloaded timezone
                lastDownloadedTimezone = lastDownloadedTime.tzinfo
                lastUpdatedTime = lastUpdatedTime.astimezone(lastDownloadedTimezone)
                
                # Compare the times to determine if an update occured since lastDownloaded
                if (lastDownloadedTime < lastUpdatedTime):
                    log.warning("modId={0} hasn't updated since lastDownloaded, but the mod page has. Flagging for update!".format(modId))
                    updatesRequired.append(index)
        else:
            # Mod is new, needs to initialize update
            log.warning("modId={0} is a new mod, flagging for update!".format(modId))
            updatesRequired.append(index)
        
        outputModList.append(outputMod)
        time.sleep(0.1)
    
    updateCount = len(updatesRequired)
    if (updateCount > 0):
        log.warning("{0} mod(s) flagged for updates!".format(updateCount))
        # If the mods should be checked for updates. 
        # Boolean. Will default to "False" on invalid input
        addressUpdates = InputManager.falsyBooleanInput("Address updates (y/*)? ", "y")
        time.sleep(pauseTime)
        
        # If positive input received
        if (addressUpdates):
            
            batchUpdate = InputManager.falsyBooleanInput("Open links en masse (y/*, will open all at once)? ", "y")
            time.sleep(pauseTime)
            batchLinks = []
            
            timeNow = datetime.now().astimezone(timezone.utc).isoformat(timespec='microseconds')
            # For each index flagged, address updates individually
            for i,index in enumerate(updatesRequired):
                # Assemble mod info for use
                modName = outputModList[index]["name"]
                modId = outputModList[index]["id"]
                modUrl = outputModList[index]["url"]
                modUpdatedTime = outputModList[index]["updatedTime"]
                modLastDownloaded = outputModList[index]["lastDownloaded"]
                modIsNew = (not (index < inputCount))
                
                # Log mod info
                log.info("Mod Update #{0}/{1} \n\tName: {2}\n\tID: {3}\n\tURL: {4}\n\tIs new mod: {5}\n\tMod Page Updated: {6}\n\tLast Downloaded: {7}\n".format((i+1),updateCount,modName,modId,modUrl,modIsNew,modUpdatedTime,modLastDownloaded))
                
                # Ask if you want to address this specific update
                addressModUpdate = InputManager.falsyBooleanInput("Open modpage (y/*)? ", "y")
                time.sleep(pauseTime)
                if (addressModUpdate):
                    # If batch links are enabled, add to list of links to open
                    if (batchUpdate):
                        batchLinks.append(modUrl)
                    else:
                        # Open the mod individually and prompt for input when done
                        webbrowser.open(modUrl)
                        # Wait for user input before proceeding
                        InputManager.waitInput("Press enter/return when ready to continue...")
                        time.sleep(pauseTime)
                
                # Ask if you want to update lastDownloaded to current time
                addLastDownloaded = InputManager.falsyBooleanInput("Add current time as lastDownloaded (y/*)? ", "y")
                time.sleep(pauseTime)
                if (addLastDownloaded):
                    outputModList[index]["lastDownloaded"] = timeNow
                    
                batchCount = len(batchLinks)
            if (batchUpdate and (batchCount > 0) ):
                log.warning("Opening {0} mod page(s)! This may take a minute...".format(batchCount))
                for link in batchLinks:
                    webbrowser.open(link)
                    time.sleep(0.5)
                
                log.info("Finished opening {0} mod pages!".format(batchCount))
            
            log.info("Finished addressing all {0} updates!".format(updateCount))
        else:
            # Negative input was received
            log.info("Ignoring updates!")
    
    
    
    
    
    
    # Log final outputModList result
    log.info("Output Mod List:\n{0}".format(outputModList))
    
    
    # Save to file
    
    # Generate new file name
    outputFileName = fileName
    
    newFileName = InputManager.falsyBooleanInput("New file name (y/*)? ", "y")
    time.sleep(pauseTime)
    
    if (newFileName):
        outputFileName = InputManager.basicInput("Enter new file name: ")
        time.sleep(pauseTime)
    
    
    # Remove file extension if it exists
    if (outputFileName[-len(fileExtension):] == fileExtension):
        outputFileName = outputFileName[:-len(fileExtension)]
        
    # Generate default output file path
    outputFilePath = Path(outputFileDirectory + outputFileName + fileExtension)
    
    
    # If the output file name already exists, increase increment until new file name is reached
    if Path.exists(outputFilePath):
        log.warning("{0}{1} already exists!".format(outputFileName,fileExtension))
        index = 0
        while Path.exists(outputFilePath):
            index += 1
            outputFilePath = Path(outputFileDirectory + outputFileName + " (" + str(index) + ")" + fileExtension)
    
    
    log.info("Saving mod list as \"{0}\"".format(outputFilePath))
    
    # Save output contents
    with open(outputFilePath, 'w', encoding='utf-8') as f:
        json.dump(outputModList, f, ensure_ascii=False, indent=4)
    
if __name__ == '__main__':
    main()